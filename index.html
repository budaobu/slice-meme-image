<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO 优化部分 (Updated) -->
    <title>表情包切片工具 - 在线图片九宫格裁剪 / GIF动图生成 / 一键打包</title>
    <meta name="description" content="免费在线表情包制作工具，提供图片网格自动裁剪（支持6x4, 7x4等自定义布局）与GIF动图合成功能。支持一键拖拽上传、点击筛选特定切片、自定义去除边框间隙(Padding)。所有图片处理均在本地浏览器纯前端完成，无需上传服务器，安全高效且无水印。">
    <meta name="keywords" content="表情包切片,九宫格切图,在线图片裁剪,GIF生成器,动图制作,图片分割,Web前端工具,无水印,Grid Splitter,Image Slicer">
    <meta name="author" content="Li Zhaoshui">
    <meta name="robots" content="index, follow">

    <!-- Open Graph (Updated) -->
    <meta property="og:title" content="表情包切片与GIF生成工具">
    <meta property="og:description" content="一键将大图按网格切分为小图并打包下载，或合成为GIF动图。支持自定义行列、点击筛选和边框调整，本地安全处理。">
    <meta property="og:type" content="website">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- GIF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap');

        body {
            background-color: #f8fafc;
            color: #334155;
            font-family: "Inter", "Noto Sans SC", sans-serif;
        }

        /* 虚线上传区域动画 */
        .upload-zone {
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='12' ry='12' stroke='%23CBD5E1FF' stroke-width='2' stroke-dasharray='8%2c 8' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
            transition: all 0.2s ease;
        }
        .upload-zone:hover, .upload-zone.drag-active {
            background-color: #eff6ff;
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='12' ry='12' stroke='%233B82F6FF' stroke-width='2' stroke-dasharray='8%2c 8' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
        }

        /* 滑块样式 */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px;
            border-radius: 50%; background: #2563eb;
            cursor: pointer; margin-top: -6px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            cursor: pointer; background: #e2e8f0; border-radius: 2px;
        }
        input[type=range]:focus::-webkit-slider-runnable-track { background: #cbd5e1; }
    </style>
</head>
<body class="min-h-screen py-10 px-4 md:px-8 flex flex-col items-center relative">

    <!-- Buy Me A Coffee -->
    <a href="https://buymeacoffee.com/lizhaoshui" target="_blank" rel="noopener noreferrer" 
       class="absolute top-4 right-4 md:top-6 md:right-8 bg-[#FFDD00] text-slate-800 p-2.5 rounded-full shadow-sm hover:shadow-md transition-all hover:-translate-y-0.5 active:scale-95 group z-50" 
       title="Buy me a coffee">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-slate-900">
            <path d="M18 8h1a4 4 0 0 1 0 8h-1"></path>
            <path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path>
            <line x1="6" y1="1" x2="6" y2="4"></line>
            <line x1="10" y1="1" x2="10" y2="4"></line>
            <line x1="14" y1="1" x2="14" y2="4"></line>
        </svg>
    </a>

    <!-- Header -->
    <header class="text-center mb-10">
        <div class="flex items-center justify-center gap-2 mb-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#2563eb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/>
                <line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/>
                <line x1="8.12" y1="8.12" x2="12" y2="12"/>
            </svg>
            <h1 class="text-3xl font-bold text-slate-800 tracking-tight">表情包切片工具</h1>
        </div>
        <p class="text-slate-500">上传 6x4 (或自定义) 的表情包合集，自动裁剪并打包下载</p>
    </header>

    <!-- Main Layout -->
    <div class="max-w-6xl w-full grid grid-cols-1 lg:grid-cols-12 gap-8 items-stretch">
        
        <!-- Left Column: Controls (CLEANED: No Upload Here) -->
        <div class="lg:col-span-4 space-y-6 flex flex-col">
            <div class="bg-white rounded-2xl p-6 shadow-sm border border-slate-200 h-full flex flex-col">
                
                <!-- Settings -->
                <div class="mb-6 flex-grow">
                    <h2 class="text-sm font-bold text-slate-800 mb-3 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2 text-slate-500"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/></svg>
                        网格与裁剪设置
                    </h2>
                    
                    <div class="grid grid-cols-2 gap-4 mb-5">
                        <div>
                            <label class="block text-xs font-medium text-slate-500 mb-1.5">列数 (宽)</label>
                            <input type="number" id="colInput" value="6" min="1" 
                                class="w-full p-2.5 bg-slate-50 border border-slate-200 rounded-lg text-slate-800 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all font-medium">
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-slate-500 mb-1.5">行数 (高)</label>
                            <input type="number" id="rowInput" value="4" min="1" 
                                class="w-full p-2.5 bg-slate-50 border border-slate-200 rounded-lg text-slate-800 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all font-medium">
                        </div>
                    </div>

                    <!-- Padding Slider -->
                    <div class="mb-5 bg-slate-50 p-3 rounded-lg border border-slate-100">
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-xs font-bold text-slate-600 flex items-center">
                                去除边框 (Padding)
                            </label>
                            <span id="paddingValue" class="text-xs font-bold text-blue-600 bg-blue-50 px-2 py-0.5 rounded">0px</span>
                        </div>
                        <input type="range" id="paddingInput" min="0" max="60" value="0" step="1"
                            class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600 block mb-2">
                        <p class="text-[10px] text-slate-400 leading-tight">
                            增加此数值以向内裁剪，避开原本的黑色分割线。
                        </p>
                    </div>

                    <!-- Filename Prefix -->
                    <div class="mb-2">
                        <label class="block text-xs font-medium text-slate-500 mb-1.5">文件名前缀</label>
                        <input type="text" id="prefixInput" value="sticker" placeholder="例如: emoji"
                            class="w-full p-2.5 bg-slate-50 border border-slate-200 rounded-lg text-slate-800 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all text-sm">
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="mt-auto space-y-4">
                    <!-- ZIP Button -->
                    <button id="processBtn" disabled class="w-full bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-bold py-3.5 px-4 rounded-xl shadow-md shadow-blue-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none transition-all flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                        <span id="btnText">裁剪并下载 ZIP</span>
                    </button>

                    <!-- GIF Section Divider -->
                    <div class="relative py-2">
                        <div class="absolute inset-0 flex items-center"><div class="w-full border-t border-slate-200"></div></div>
                        <div class="relative flex justify-center"><span class="bg-white px-3 text-xs text-slate-400 font-medium">或生成动图</span></div>
                    </div>

                    <!-- GIF Controls -->
                    <div class="bg-slate-50 rounded-xl p-4 border border-slate-100">
                        <div class="flex items-center gap-3 mb-3">
                            <label class="text-xs font-medium text-slate-600 whitespace-nowrap">每帧间隔(ms)</label>
                            <input type="number" id="gifDelayInput" value="100" min="10" step="10"
                                class="w-full p-1.5 bg-white border border-slate-200 rounded text-center text-sm font-medium focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none">
                        </div>
                        <button id="gifBtn" disabled class="w-full bg-purple-600 hover:bg-purple-700 active:bg-purple-800 text-white font-bold py-3 px-4 rounded-lg shadow-md shadow-purple-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none transition-all flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="2" y1="7" x2="7" y2="7"/><line x1="2" y1="17" x2="7" y2="17"/><line x1="17" y1="17" x2="22" y2="17"/><line x1="17" y1="7" x2="22" y2="7"/></svg>
                            <span id="gifBtnText">生成 GIF</span>
                        </button>
                    </div>
                </div>

            </div>

            <!-- Success Message -->
            <div id="successMsg" class="hidden bg-emerald-50 border border-emerald-100 rounded-xl p-4 flex items-start gap-3">
                <div class="bg-emerald-100 p-1 rounded-full text-emerald-600 mt-0.5">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>
                </div>
                <div>
                    <h4 class="text-sm font-bold text-emerald-800">成功!</h4>
                    <p class="text-xs text-emerald-600 mt-0.5" id="successText">操作完成。</p>
                </div>
            </div>
        </div>

        <!-- Right Column: Preview & Upload -->
        <div class="lg:col-span-8 flex flex-col">
            <div class="bg-white rounded-2xl shadow-sm border border-slate-200 flex flex-col h-full min-h-[500px]">
                
                <!-- Preview Header -->
                <div class="px-6 py-4 border-b border-slate-100 flex flex-col sm:flex-row justify-between items-center gap-4">
                    <h2 class="text-lg font-bold text-slate-800 flex items-center self-start sm:self-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2 text-slate-500"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                        预览确认
                    </h2>
                    
                    <div class="flex items-center gap-2 self-end sm:self-center">
                        <!-- Select All Btn -->
                        <button id="selectAllBtn" class="flex items-center gap-1 px-2.5 py-1.5 text-xs font-medium text-blue-600 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors border border-blue-100" title="全选">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>
                            全选
                        </button>
                        
                        <!-- Reset Btn -->
                        <button id="resetBtn" class="flex items-center gap-1 px-2.5 py-1.5 text-xs font-medium text-slate-600 bg-slate-50 hover:bg-slate-100 rounded-lg transition-colors border border-slate-200" title="取消所有选择">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
                            重置
                        </button>

                        <span class="bg-slate-100 text-slate-500 text-xs font-semibold px-2.5 py-1.5 rounded-md ml-1">
                            切片: <span id="sliceCount">24</span>
                        </span>
                    </div>
                </div>

                <!-- Canvas Area (Acts as Drop Zone initially) -->
                <div class="flex-1 p-6 bg-slate-50 flex items-center justify-center overflow-hidden relative">
                    
                    <!-- Integrated Upload Zone -->
                    <label id="dropZone" class="upload-zone w-full h-full min-h-[300px] flex flex-col items-center justify-center cursor-pointer rounded-xl border-2 border-dashed border-slate-300 hover:border-blue-400 bg-white/50 hover:bg-blue-50/50 transition-all">
                        <div class="flex flex-col items-center p-6 text-center">
                            <div class="w-16 h-16 bg-blue-50 rounded-full flex items-center justify-center mb-4 text-blue-500">
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                            </div>
                            <h3 class="text-lg font-bold text-slate-700 mb-2">点击或拖拽上传图片</h3>
                            <p class="text-slate-500 text-sm max-w-xs">支持 JPG, PNG 等常见格式。<br>上传后将自动应用网格设置。</p>
                        </div>
                        <!-- Hidden Input INSIDE label to ensure click works -->
                        <input type="file" id="fileInput" accept="image/*" class="hidden" />
                    </label>

                    <!-- Image Container (Hidden initially) -->
                    <div id="previewContainer" class="hidden shadow-lg rounded-lg overflow-hidden relative" style="max-width: 100%; max-height: 600px;">
                        <img id="sourceImage" src="" alt="Source" class="block max-w-full h-auto" style="max-height: 600px;">
                        <canvas id="gridOverlay" class="absolute top-0 left-0 w-full h-full cursor-pointer"></canvas>
                    </div>
                </div>

                <!-- Footer Tip -->
                <div class="px-6 py-4 bg-white border-t border-slate-100 text-center">
                    <p class="text-xs text-slate-400">
                        提示: <span class="text-red-500 font-bold">红色虚线</span>为网格，<span class="text-blue-500 font-bold">点击网格</span>可选定下载，<span class="text-green-600 font-bold">绿色</span>为选中。
                    </p>
                </div>

            </div>
        </div>

    </div>

    <div class="mt-12 text-slate-400 text-xs text-center">
        本地安全处理，图片不会上传至服务器
    </div>

    <!-- Hidden canvas for processing -->
    <canvas id="processCanvas" class="hidden"></canvas>

    <script>
        // --- 1. Worker Loader Hack for GIF.js ---
        let gifWorkerBlobURL = null;
        const gifWorkerUrl = 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js';
        
        fetch(gifWorkerUrl)
            .then(resp => {
                if(!resp.ok) throw new Error("Worker fetch failed");
                return resp.text();
            })
            .then(text => {
                const blob = new Blob([text], { type: 'application/javascript' });
                gifWorkerBlobURL = URL.createObjectURL(blob);
                console.log("GIF Worker loaded.");
            })
            .catch(err => {
                console.warn("GIF Worker load failed:", err);
            });

        // DOM Elements
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const colInput = document.getElementById('colInput');
        const rowInput = document.getElementById('rowInput');
        const paddingInput = document.getElementById('paddingInput');
        const paddingValue = document.getElementById('paddingValue');
        const prefixInput = document.getElementById('prefixInput');
        const gifDelayInput = document.getElementById('gifDelayInput');
        
        const processBtn = document.getElementById('processBtn');
        const btnText = document.getElementById('btnText');
        const gifBtn = document.getElementById('gifBtn');
        const gifBtnText = document.getElementById('gifBtnText');
        
        const previewContainer = document.getElementById('previewContainer');
        const sourceImage = document.getElementById('sourceImage');
        const gridOverlay = document.getElementById('gridOverlay');
        const sliceCountDisplay = document.getElementById('sliceCount');
        
        const successMsg = document.getElementById('successMsg');
        const successText = document.getElementById('successText');

        const selectAllBtn = document.getElementById('selectAllBtn');
        const resetBtn = document.getElementById('resetBtn');

        const processCanvas = document.getElementById('processCanvas');
        const ctx = processCanvas.getContext('2d', { willReadFrequently: true });

        // State
        let currentFile = null;
        let originalImageWidth = 0;
        let originalImageHeight = 0;
        let selectedIndices = new Set(); 

        // --- Event Listeners ---

        fileInput.addEventListener('change', handleFileSelect);

        // Upload Zone Drag & Drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-active');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-active');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-active');
            if (e.dataTransfer.files.length > 0) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect({ target: fileInput });
            }
        });

        // Also allow drag & drop on the preview container to replace image
        previewContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        previewContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            if (e.dataTransfer.files.length > 0) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect({ target: fileInput });
            }
        });

        const inputs = [colInput, rowInput, paddingInput];
        inputs.forEach(input => {
            input.addEventListener('input', () => {
                if(input === paddingInput) paddingValue.textContent = input.value + 'px';
                if(input !== paddingInput) selectedIndices.clear();
                updateGridOverlay();
                updateButtonState();
            });
        });

        gridOverlay.addEventListener('click', handleGridClick);

        selectAllBtn.addEventListener('click', () => {
            if (!sourceImage.src) return;
            const cols = parseInt(colInput.value) || 6;
            const rows = parseInt(rowInput.value) || 4;
            const total = cols * rows;
            selectedIndices.clear();
            for(let i=0; i<total; i++) selectedIndices.add(i);
            updateGridOverlay();
            updateButtonState();
        });

        resetBtn.addEventListener('click', () => {
            if (!sourceImage.src) return;
            selectedIndices.clear();
            updateGridOverlay();
            updateButtonState();
        });

        processBtn.addEventListener('click', processAndZip);
        gifBtn.addEventListener('click', processAndGif);
        
        window.addEventListener('resize', updateGridOverlay);


        // --- Functions ---

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            currentFile = file;
            const reader = new FileReader();

            reader.onload = function(event) {
                sourceImage.src = event.target.result;
                sourceImage.onload = () => {
                    originalImageWidth = sourceImage.naturalWidth;
                    originalImageHeight = sourceImage.naturalHeight;
                    
                    selectedIndices.clear();
                    
                    // Toggle Views: Hide DropZone, Show Preview
                    dropZone.classList.add('hidden');
                    previewContainer.classList.remove('hidden');
                    
                    processBtn.disabled = false;
                    gifBtn.disabled = false;
                    successMsg.classList.add('hidden');

                    updateButtonState();
                    setTimeout(updateGridOverlay, 50);
                };
            };
            reader.readAsDataURL(file);
        }

        function handleGridClick(e) {
            if (!sourceImage.src) return;
            const rect = gridOverlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cols = parseInt(colInput.value) || 6;
            const rows = parseInt(rowInput.value) || 4;
            
            const cellW = gridOverlay.width / cols;
            const cellH = gridOverlay.height / rows;

            const colIndex = Math.floor(x / cellW);
            const rowIndex = Math.floor(y / cellH);

            if (colIndex >= 0 && colIndex < cols && rowIndex >= 0 && rowIndex < rows) {
                const index = rowIndex * cols + colIndex;
                if (selectedIndices.has(index)) selectedIndices.delete(index);
                else selectedIndices.add(index);
                updateGridOverlay();
                updateButtonState();
            }
        }

        function updateButtonState() {
            const cols = parseInt(colInput.value) || 6;
            const rows = parseInt(rowInput.value) || 4;
            const total = cols * rows;
            const selected = selectedIndices.size;
            
            sliceCountDisplay.textContent = total;

            const label = selected > 0 ? `选中 (${selected})` : `全部 (${total})`;
            btnText.textContent = `下载${label} ZIP`;
            gifBtnText.textContent = `生成${label} GIF`;
        }

        function updateGridOverlay() {
            if (!sourceImage.src || sourceImage.src === "") return;

            const cols = parseInt(colInput.value) || 6;
            const rows = parseInt(rowInput.value) || 4;
            const padding = parseInt(paddingInput.value) || 0;

            const rect = sourceImage.getBoundingClientRect();
            gridOverlay.width = rect.width;
            gridOverlay.height = rect.height;

            const oCtx = gridOverlay.getContext('2d');
            oCtx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);

            const cellW = gridOverlay.width / cols;
            const cellH = gridOverlay.height / rows;
            const scaleFactor = gridOverlay.width / originalImageWidth;
            const displayPadding = padding * scaleFactor;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const index = r * cols + c;
                    const x = c * cellW;
                    const y = r * cellH;
                    
                    const padX = x + displayPadding;
                    const padY = y + displayPadding;
                    const padW = cellW - 2 * displayPadding;
                    const padH = cellH - 2 * displayPadding;

                    if (selectedIndices.has(index)) {
                        oCtx.fillStyle = 'rgba(34, 197, 94, 0.4)';
                        if (padW > 0 && padH > 0) oCtx.fillRect(padX, padY, padW, padH);
                        else oCtx.fillRect(x, y, cellW, cellH);

                        oCtx.fillStyle = '#ffffff';
                        oCtx.font = "bold 24px Arial";
                        oCtx.textAlign = "center";
                        oCtx.textBaseline = "middle";
                        oCtx.fillText("✓", x + cellW/2, y + cellH/2);
                    }
                    
                    if (padding > 0 && padW > 0 && padH > 0) {
                        oCtx.strokeStyle = 'rgba(37, 99, 235, 0.9)';
                        oCtx.lineWidth = 1.5;
                        oCtx.setLineDash([]);
                        oCtx.strokeRect(padX, padY, padW, padH);
                    }
                }
            }

            oCtx.strokeStyle = 'rgba(239, 68, 68, 0.6)';
            oCtx.lineWidth = 1;
            oCtx.setLineDash([4, 2]); 
            oCtx.beginPath();

            for (let i = 1; i < cols; i++) {
                const x = i * cellW;
                oCtx.moveTo(x, 0);
                oCtx.lineTo(x, gridOverlay.height);
            }
            for (let j = 1; j < rows; j++) {
                const y = j * cellH;
                oCtx.moveTo(0, y);
                oCtx.lineTo(gridOverlay.width, y);
            }
            oCtx.stroke();
            
            oCtx.setLineDash([]);
            oCtx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
            oCtx.strokeRect(0, 0, gridOverlay.width, gridOverlay.height);
        }

        // --- Common Slice Logic ---
        async function iterateSlices(callback) {
            const cols = parseInt(colInput.value);
            const rows = parseInt(rowInput.value);
            const padding = parseInt(paddingInput.value) || 0;
            const cellW = originalImageWidth / cols;
            const cellH = originalImageHeight / rows;
            let globalIndex = 0;
            let processedCount = 0;
            const hasSelection = selectedIndices.size > 0;

            const promises = [];

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const currentIndex = globalIndex++;
                    
                    if (hasSelection && !selectedIndices.has(currentIndex)) continue;

                    const p = new Promise(async (resolve) => {
                        const srcX = c * cellW + padding;
                        const srcY = r * cellH + padding;
                        const srcW = cellW - 2 * padding;
                        const srcH = cellH - 2 * padding;

                        if (srcW <= 0 || srcH <= 0) {
                            resolve();
                            return;
                        }

                        // Create a temp canvas for this slice
                        const cellCanvas = document.createElement('canvas');
                        cellCanvas.width = srcW;
                        cellCanvas.height = srcH;
                        const cellCtx = cellCanvas.getContext('2d');
                        cellCtx.drawImage(sourceImage, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);

                        await callback(cellCanvas, currentIndex, processedCount);
                        processedCount++;
                        resolve();
                    });
                    promises.push(p);
                }
            }
            await Promise.all(promises);
            return processedCount;
        }

        async function processAndZip() {
            if (!currentFile) return;

            const prefix = prefixInput.value.trim() || "sticker";
            const zip = new JSZip();
            const folder = zip.folder(prefix + "_pack");

            processBtn.disabled = true;
            gifBtn.disabled = true;
            const originalBtnText = btnText.textContent;
            btnText.textContent = "处理中...";
            successMsg.classList.add('hidden');

            const count = await iterateSlices((canvas, index) => {
                return new Promise(resolve => {
                    canvas.toBlob(blob => {
                        if (blob) {
                            const fileName = `${prefix}_${String(index + 1).padStart(2, '0')}.png`;
                            folder.file(fileName, blob);
                        }
                        resolve();
                    }, 'image/png');
                });
            });

            if (count === 0) {
                resetUI(originalBtnText);
                alert("没有可处理的切片");
                return;
            }

            btnText.textContent = "正在压缩...";
            zip.generateAsync({type:"blob"}).then(function(content) {
                downloadBlob(content, `${prefix}_pack.zip`);
                resetUI(originalBtnText);
                showSuccess(`已打包 ${count} 张图片`);
            });
        }

        async function processAndGif() {
            if (!currentFile) return;
            if (!gifWorkerBlobURL) {
                alert("GIF 组件尚未加载完成，请稍后再试或检查网络连接。");
                return;
            }

            const prefix = prefixInput.value.trim() || "animation";
            const delay = parseInt(gifDelayInput.value) || 100;

            processBtn.disabled = true;
            gifBtn.disabled = true;
            const originalBtnText = gifBtnText.textContent;
            gifBtnText.textContent = "渲染中...";
            successMsg.classList.add('hidden');

            const cols = parseInt(colInput.value);
            const rows = parseInt(rowInput.value);
            const padding = parseInt(paddingInput.value) || 0;
            const cellW = (originalImageWidth / cols) - 2 * padding;
            const cellH = (originalImageHeight / rows) - 2 * padding;

            if (cellW <= 0 || cellH <= 0) {
                resetUI(null, originalBtnText);
                alert("切片尺寸无效");
                return;
            }

            const gif = new GIF({
                workers: 2,
                quality: 10,
                width: cellW,
                height: cellH,
                workerScript: gifWorkerBlobURL
            });

            const slices = [];

            const count = await iterateSlices((canvas, index) => {
                slices.push({ index, canvas }); 
            });

            if (count === 0) {
                resetUI(null, originalBtnText);
                alert("没有可处理的切片");
                return;
            }

            slices.sort((a, b) => a.index - b.index);

            slices.forEach(item => {
                gif.addFrame(item.canvas, {delay: delay});
            });

            gif.on('finished', function(blob) {
                downloadBlob(blob, `${prefix}.gif`);
                resetUI(null, originalBtnText);
                showSuccess(`GIF 已生成 (${count} 帧)`);
            });

            gif.render();
        }

        function downloadBlob(blob, filename) {
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function resetUI(zipText, gifText) {
            processBtn.disabled = false;
            gifBtn.disabled = false;
            if (zipText) btnText.textContent = zipText;
            if (gifText) gifBtnText.textContent = gifText;
        }

        function showSuccess(msg) {
            successText.textContent = msg;
            successMsg.classList.remove('hidden');
        }
        
        // Init
        updateButtonState();
    </script>
</body>
</html>
