<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO 优化部分 -->
    <title>表情包切片工具 - 在线图片网格自动裁剪与打包下载</title>
    <meta name="description" content="免费在线表情包切片工具，支持6x4、7x4等自定义网格自动裁剪。一键上传图片，智能分割并打包下载ZIP。支持点击选择特定切片下载，支持去除边框间隙(Padding)，本地浏览器纯前端处理，无需上传服务器，保护隐私安全。">
    <meta name="keywords" content="表情包切片,图片分割,九宫格切图,在线图片裁剪,表情包制作,Grid Splitter,Image Slicer,图片切片器,无需PS">
    <meta name="author" content="Li Zhaoshui">
    <meta name="robots" content="index, follow">

    <!-- Open Graph -->
    <meta property="og:title" content="表情包切片工具 - 在线图片网格自动裁剪">
    <meta property="og:description" content="一键将大图按网格切分为小图并打包下载，支持自定义行列、点击筛选和边框调整，本地安全处理。">
    <meta property="og:type" content="website">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap');

        body {
            background-color: #f8fafc;
            color: #334155;
            font-family: "Inter", "Noto Sans SC", sans-serif;
        }

        /* 虚线上传区域动画 */
        .upload-zone {
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='12' ry='12' stroke='%23CBD5E1FF' stroke-width='2' stroke-dasharray='8%2c 8' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
            transition: all 0.2s ease;
        }
        .upload-zone:hover, .upload-zone.drag-active {
            background-color: #eff6ff;
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='12' ry='12' stroke='%233B82F6FF' stroke-width='2' stroke-dasharray='8%2c 8' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
        }

        input[type="file"] { display: none; }

        /* 滑块样式 */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px;
            border-radius: 50%; background: #2563eb;
            cursor: pointer; margin-top: -6px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            cursor: pointer; background: #e2e8f0; border-radius: 2px;
        }
        input[type=range]:focus::-webkit-slider-runnable-track { background: #cbd5e1; }
    </style>
</head>
<body class="min-h-screen py-10 px-4 md:px-8 flex flex-col items-center relative">

    <!-- Buy Me A Coffee -->
    <a href="https://buymeacoffee.com/lizhaoshui" target="_blank" rel="noopener noreferrer" 
       class="absolute top-4 right-4 md:top-6 md:right-8 bg-[#FFDD00] text-slate-800 p-2.5 rounded-full shadow-sm hover:shadow-md transition-all hover:-translate-y-0.5 active:scale-95 group z-50" 
       title="Buy me a coffee">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-slate-900">
            <path d="M18 8h1a4 4 0 0 1 0 8h-1"></path>
            <path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path>
            <line x1="6" y1="1" x2="6" y2="4"></line>
            <line x1="10" y1="1" x2="10" y2="4"></line>
            <line x1="14" y1="1" x2="14" y2="4"></line>
        </svg>
    </a>

    <!-- Header -->
    <header class="text-center mb-10">
        <div class="flex items-center justify-center gap-2 mb-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#2563eb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/>
                <line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/>
                <line x1="8.12" y1="8.12" x2="12" y2="12"/>
            </svg>
            <h1 class="text-3xl font-bold text-slate-800 tracking-tight">表情包切片工具</h1>
        </div>
        <p class="text-slate-500">上传 6x4 (或自定义) 的表情包合集，自动裁剪并打包下载</p>
    </header>

    <!-- Main Layout -->
    <div class="max-w-6xl w-full grid grid-cols-1 lg:grid-cols-12 gap-8 items-stretch">
        
        <!-- Left Column: Controls -->
        <div class="lg:col-span-4 space-y-6 flex flex-col">
            <div class="bg-white rounded-2xl p-6 shadow-sm border border-slate-200 h-full flex flex-col">
                
                <!-- 1. Upload -->
                <div class="mb-6">
                    <h2 class="text-sm font-bold text-slate-800 mb-3 flex items-center">
                        <span class="bg-slate-100 text-slate-600 px-2 py-0.5 rounded text-xs mr-2">1</span>
                        上传图片
                    </h2>
                    <label id="dropZone" class="upload-zone w-full h-32 flex flex-col items-center justify-center cursor-pointer rounded-xl">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-slate-400 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                        </svg>
                        <span class="text-sm text-slate-500 font-medium">点击或拖拽上传图片</span>
                        <input type="file" id="fileInput" accept="image/*" />
                    </label>
                </div>

                <!-- 2. Settings -->
                <div class="mb-6 flex-grow">
                    <h2 class="text-sm font-bold text-slate-800 mb-3 flex items-center">
                        <span class="bg-slate-100 text-slate-600 px-2 py-0.5 rounded text-xs mr-2">2</span>
                        网格与裁剪设置
                    </h2>
                    
                    <div class="grid grid-cols-2 gap-4 mb-5">
                        <div>
                            <label class="block text-xs font-medium text-slate-500 mb-1.5">列数 (宽)</label>
                            <input type="number" id="colInput" value="6" min="1" 
                                class="w-full p-2.5 bg-slate-50 border border-slate-200 rounded-lg text-slate-800 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all font-medium">
                        </div>
                        <div>
                            <label class="block text-xs font-medium text-slate-500 mb-1.5">行数 (高)</label>
                            <input type="number" id="rowInput" value="4" min="1" 
                                class="w-full p-2.5 bg-slate-50 border border-slate-200 rounded-lg text-slate-800 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all font-medium">
                        </div>
                    </div>

                    <!-- Padding Slider -->
                    <div class="mb-5 bg-slate-50 p-3 rounded-lg border border-slate-100">
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-xs font-bold text-slate-600 flex items-center">
                                去除边框 (Padding)
                            </label>
                            <span id="paddingValue" class="text-xs font-bold text-blue-600 bg-blue-50 px-2 py-0.5 rounded">0px</span>
                        </div>
                        <input type="range" id="paddingInput" min="0" max="60" value="0" step="1"
                            class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600 block mb-2">
                        <p class="text-[10px] text-slate-400 leading-tight">
                            增加此数值以向内裁剪，避开原本的黑色分割线。
                        </p>
                    </div>

                    <!-- Filename Prefix -->
                    <div class="mb-2">
                        <label class="block text-xs font-medium text-slate-500 mb-1.5">文件名前缀</label>
                        <input type="text" id="prefixInput" value="sticker" placeholder="例如: emoji"
                            class="w-full p-2.5 bg-slate-50 border border-slate-200 rounded-lg text-slate-800 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all text-sm">
                    </div>
                </div>

                <!-- Action Button -->
                <button id="processBtn" disabled class="w-full bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-bold py-3.5 px-4 rounded-xl shadow-md shadow-blue-200 disabled:opacity-50 disabled:cursor-not-allowed disabled:shadow-none transition-all flex items-center justify-center gap-2 mt-auto">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    <span id="btnText">裁剪并下载 ZIP</span>
                </button>

            </div>

            <!-- Success Message -->
            <div id="successMsg" class="hidden bg-emerald-50 border border-emerald-100 rounded-xl p-4 flex items-start gap-3">
                <div class="bg-emerald-100 p-1 rounded-full text-emerald-600 mt-0.5">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>
                </div>
                <div>
                    <h4 class="text-sm font-bold text-emerald-800">成功!</h4>
                    <p class="text-xs text-emerald-600 mt-0.5" id="successText">已打包 24 张表情包。</p>
                </div>
            </div>
        </div>

        <!-- Right Column: Preview -->
        <div class="lg:col-span-8 flex flex-col">
            <div class="bg-white rounded-2xl shadow-sm border border-slate-200 flex flex-col h-full min-h-[500px]">
                
                <!-- Preview Header -->
                <div class="px-6 py-4 border-b border-slate-100 flex flex-col sm:flex-row justify-between items-center gap-4">
                    <h2 class="text-lg font-bold text-slate-800 flex items-center self-start sm:self-center">
                        <span class="text-slate-400 font-normal mr-2">3.</span>
                        预览确认
                    </h2>
                    
                    <div class="flex items-center gap-2 self-end sm:self-center">
                        <!-- Select All Btn -->
                        <button id="selectAllBtn" class="flex items-center gap-1 px-2.5 py-1.5 text-xs font-medium text-blue-600 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors border border-blue-100" title="全选">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>
                            全选
                        </button>
                        
                        <!-- Reset Btn -->
                        <button id="resetBtn" class="flex items-center gap-1 px-2.5 py-1.5 text-xs font-medium text-slate-600 bg-slate-50 hover:bg-slate-100 rounded-lg transition-colors border border-slate-200" title="取消所有选择">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
                            重置
                        </button>

                        <span class="bg-slate-100 text-slate-500 text-xs font-semibold px-2.5 py-1.5 rounded-md ml-1">
                            切片: <span id="sliceCount">24</span>
                        </span>
                    </div>
                </div>

                <!-- Canvas Area -->
                <div class="flex-1 p-6 bg-slate-50 flex items-center justify-center overflow-hidden relative">
                    
                    <!-- Empty State -->
                    <div id="emptyState" class="text-center">
                        <div class="w-20 h-20 bg-slate-200 rounded-full mx-auto mb-4 flex items-center justify-center text-slate-400">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                        </div>
                        <p class="text-slate-400 text-sm">请先在左侧上传图片</p>
                    </div>

                    <!-- Image Container -->
                    <div id="previewContainer" class="hidden shadow-lg rounded-lg overflow-hidden relative" style="max-width: 100%; max-height: 600px;">
                        <img id="sourceImage" src="" alt="Source" class="block max-w-full h-auto" style="max-height: 600px;">
                        <!-- Updated canvas with cursor-pointer -->
                        <canvas id="gridOverlay" class="absolute top-0 left-0 w-full h-full cursor-pointer"></canvas>
                    </div>
                </div>

                <!-- Footer Tip -->
                <div class="px-6 py-4 bg-white border-t border-slate-100 text-center">
                    <p class="text-xs text-slate-400">
                        提示: <span class="text-red-500 font-bold">红色虚线</span>为网格，<span class="text-blue-500 font-bold">点击网格</span>可选定下载，<span class="text-green-600 font-bold">绿色</span>为选中。
                    </p>
                </div>

            </div>
        </div>

    </div>

    <div class="mt-12 text-slate-400 text-xs text-center">
        本地安全处理，图片不会上传至服务器
    </div>

    <!-- Hidden canvas for processing -->
    <canvas id="processCanvas" class="hidden"></canvas>

    <script>
        // DOM Elements
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const colInput = document.getElementById('colInput');
        const rowInput = document.getElementById('rowInput');
        const paddingInput = document.getElementById('paddingInput');
        const paddingValue = document.getElementById('paddingValue');
        const prefixInput = document.getElementById('prefixInput');
        const processBtn = document.getElementById('processBtn');
        const btnText = document.getElementById('btnText');
        
        const previewContainer = document.getElementById('previewContainer');
        const emptyState = document.getElementById('emptyState');
        const sourceImage = document.getElementById('sourceImage');
        const gridOverlay = document.getElementById('gridOverlay');
        const sliceCountDisplay = document.getElementById('sliceCount');
        
        const successMsg = document.getElementById('successMsg');
        const successText = document.getElementById('successText');

        const selectAllBtn = document.getElementById('selectAllBtn');
        const resetBtn = document.getElementById('resetBtn');

        const processCanvas = document.getElementById('processCanvas');
        const ctx = processCanvas.getContext('2d', { willReadFrequently: true });

        // State
        let currentFile = null;
        let originalImageWidth = 0;
        let originalImageHeight = 0;
        let selectedIndices = new Set(); // Store indices of selected cells

        // --- Event Listeners ---

        // File Input
        fileInput.addEventListener('change', handleFileSelect);

        // Drag & Drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-active');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-active');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-active');
            if (e.dataTransfer.files.length > 0) {
                fileInput.files = e.dataTransfer.files;
                handleFileSelect({ target: fileInput });
            }
        });

        // Inputs - Reset selections when grid changes
        colInput.addEventListener('input', () => { 
            selectedIndices.clear(); 
            updateGridOverlay(); 
            updateButtonState();
        });
        rowInput.addEventListener('input', () => { 
            selectedIndices.clear(); 
            updateGridOverlay(); 
            updateButtonState();
        });
        paddingInput.addEventListener('input', () => {
            paddingValue.textContent = paddingInput.value + 'px';
            updateGridOverlay();
        });
        
        // Canvas Click for Selection
        gridOverlay.addEventListener('click', handleGridClick);

        // Select All & Reset
        selectAllBtn.addEventListener('click', () => {
            if (!sourceImage.src) return;
            const cols = parseInt(colInput.value) || 6;
            const rows = parseInt(rowInput.value) || 4;
            const total = cols * rows;
            
            selectedIndices.clear();
            for(let i=0; i<total; i++) {
                selectedIndices.add(i);
            }
            updateGridOverlay();
            updateButtonState();
        });

        resetBtn.addEventListener('click', () => {
            if (!sourceImage.src) return;
            selectedIndices.clear();
            updateGridOverlay();
            updateButtonState();
        });

        // Button
        processBtn.addEventListener('click', processAndZip);
        
        // Window Resize
        window.addEventListener('resize', updateGridOverlay);


        // --- Functions ---

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            currentFile = file;
            const reader = new FileReader();

            reader.onload = function(event) {
                sourceImage.src = event.target.result;
                sourceImage.onload = () => {
                    originalImageWidth = sourceImage.naturalWidth;
                    originalImageHeight = sourceImage.naturalHeight;
                    
                    // Reset State
                    selectedIndices.clear();
                    emptyState.classList.add('hidden');
                    previewContainer.classList.remove('hidden');
                    processBtn.disabled = false;
                    successMsg.classList.add('hidden');

                    updateButtonState();
                    // Wait a tick for render
                    setTimeout(updateGridOverlay, 50);
                };
            };
            reader.readAsDataURL(file);
        }

        function handleGridClick(e) {
            if (!sourceImage.src) return;

            const rect = gridOverlay.getBoundingClientRect();
            // Calculate scale factors between visual size and actual canvas size
            // Note: gridOverlay.width/height is the drawing buffer size (matched to sourceImage in updateGridOverlay)
            // rect.width/height is the CSS size.
            // But we set gridOverlay.width = rect.width in updateGridOverlay, so they should match 1:1 visually
            
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cols = parseInt(colInput.value) || 6;
            const rows = parseInt(rowInput.value) || 4;
            
            const cellW = gridOverlay.width / cols;
            const cellH = gridOverlay.height / rows;

            const colIndex = Math.floor(x / cellW);
            const rowIndex = Math.floor(y / cellH);

            if (colIndex >= 0 && colIndex < cols && rowIndex >= 0 && rowIndex < rows) {
                // Linear index calculation
                const index = rowIndex * cols + colIndex;
                
                if (selectedIndices.has(index)) {
                    selectedIndices.delete(index);
                } else {
                    selectedIndices.add(index);
                }
                
                updateGridOverlay();
                updateButtonState();
            }
        }

        function updateButtonState() {
            const cols = parseInt(colInput.value) || 6;
            const rows = parseInt(rowInput.value) || 4;
            const total = cols * rows;
            const selected = selectedIndices.size;
            
            sliceCountDisplay.textContent = total;

            if (selected > 0) {
                btnText.textContent = `下载选中 (${selected})`;
            } else {
                btnText.textContent = `下载全部 (${total})`;
            }
        }

        function updateGridOverlay() {
            if (!sourceImage.src || sourceImage.src === "") return;

            const cols = parseInt(colInput.value) || 6;
            const rows = parseInt(rowInput.value) || 4;
            const padding = parseInt(paddingInput.value) || 0;

            const rect = sourceImage.getBoundingClientRect();
            gridOverlay.width = rect.width;
            gridOverlay.height = rect.height;

            const oCtx = gridOverlay.getContext('2d');
            oCtx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);

            const cellW = gridOverlay.width / cols;
            const cellH = gridOverlay.height / rows;

            // Scale Factor = Display Width / Source Width
            const scaleFactor = gridOverlay.width / originalImageWidth;
            const displayPadding = padding * scaleFactor;

            // Draw Grid & Selection
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const index = r * cols + c;
                    const x = c * cellW;
                    const y = r * cellH;
                    
                    const padX = x + displayPadding;
                    const padY = y + displayPadding;
                    const padW = cellW - 2 * displayPadding;
                    const padH = cellH - 2 * displayPadding;

                    // 1. If Selected: Draw Green Overlay & Checkmark
                    if (selectedIndices.has(index)) {
                        // Green Overlay
                        oCtx.fillStyle = 'rgba(34, 197, 94, 0.4)'; // green-500 with opacity
                        if (padW > 0 && padH > 0) {
                             oCtx.fillRect(padX, padY, padW, padH);
                        } else {
                             oCtx.fillRect(x, y, cellW, cellH);
                        }

                        // Checkmark
                        oCtx.fillStyle = '#ffffff';
                        oCtx.font = "bold 24px Arial";
                        oCtx.textAlign = "center";
                        oCtx.textBaseline = "middle";
                        oCtx.fillText("✓", x + cellW/2, y + cellH/2);
                    }
                    
                    // 2. Draw Padding Box (Blue Line) if padding > 0
                    if (padding > 0 && padW > 0 && padH > 0) {
                        oCtx.strokeStyle = 'rgba(37, 99, 235, 0.9)'; // Blue-600
                        oCtx.lineWidth = 1.5;
                        oCtx.setLineDash([]);
                        oCtx.strokeRect(padX, padY, padW, padH);
                    }
                }
            }

            // 3. Draw Basic Grid Lines (Red Dashed) on top
            oCtx.strokeStyle = 'rgba(239, 68, 68, 0.6)'; // Red-500
            oCtx.lineWidth = 1;
            oCtx.setLineDash([4, 2]); 
            oCtx.beginPath();

            for (let i = 1; i < cols; i++) {
                const x = i * cellW;
                oCtx.moveTo(x, 0);
                oCtx.lineTo(x, gridOverlay.height);
            }
            for (let j = 1; j < rows; j++) {
                const y = j * cellH;
                oCtx.moveTo(0, y);
                oCtx.lineTo(gridOverlay.width, y);
            }
            oCtx.stroke();
            
            // Border
            oCtx.setLineDash([]);
            oCtx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
            oCtx.strokeRect(0, 0, gridOverlay.width, gridOverlay.height);
        }

        async function processAndZip() {
            if (!currentFile) return;

            const cols = parseInt(colInput.value);
            const rows = parseInt(rowInput.value);
            const padding = parseInt(paddingInput.value) || 0;
            const prefix = prefixInput.value.trim() || "sticker";
            
            const zip = new JSZip();
            const folderName = prefix + "_pack";
            const folder = zip.folder(folderName);

            // UI State
            processBtn.disabled = true;
            const originalBtnText = btnText.textContent;
            btnText.textContent = "处理中...";
            successMsg.classList.add('hidden');

            // Set canvas to FULL original resolution
            processCanvas.width = originalImageWidth;
            processCanvas.height = originalImageHeight;
            ctx.drawImage(sourceImage, 0, 0);

            const cellW = originalImageWidth / cols;
            const cellH = originalImageHeight / rows;

            let processedCount = 0; // Number of items actually added to zip
            let globalIndex = 0;    // Absolute index of the cell (0 to 23)
            const promises = [];

            // Check if we are in "Selection Mode" or "Download All Mode"
            const hasSelection = selectedIndices.size > 0;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const currentIndex = globalIndex++; // Store and increment
                    
                    // If selection exists, SKIP this cell if it's NOT in the set
                    if (hasSelection && !selectedIndices.has(currentIndex)) {
                        continue; 
                    }

                    // For filename, we can either use the absolute index+1, or a running counter.
                    // Usually keeping the original order number is better for stickers (sticker_03.png),
                    // but if downloading "Selected", maybe a compact list is better?
                    // Let's use the absolute index to keep mapping clear.
                    const fileName = `${prefix}_${String(currentIndex + 1).padStart(2, '0')}.png`;

                    const p = new Promise((resolve) => {
                        const cellCanvas = document.createElement('canvas');
                        
                        // Calculate cropped dimensions
                        const srcX = c * cellW + padding;
                        const srcY = r * cellH + padding;
                        const srcW = cellW - 2 * padding;
                        const srcH = cellH - 2 * padding;

                        if (srcW <= 0 || srcH <= 0) {
                            resolve(); 
                            return;
                        }

                        cellCanvas.width = srcW;
                        cellCanvas.height = srcH;
                        const cellCtx = cellCanvas.getContext('2d');

                        cellCtx.drawImage(
                            sourceImage, 
                            srcX, srcY, srcW, srcH, 
                            0, 0, srcW, srcH
                        );

                        cellCanvas.toBlob((blob) => {
                            if (blob) {
                                folder.file(fileName, blob);
                                processedCount++;
                            }
                            resolve();
                        }, 'image/png');
                    });
                    promises.push(p);
                }
            }

            await Promise.all(promises);

            if (processedCount === 0) {
                // Should technically not happen due to UI logic, but safe guard
                processBtn.disabled = false;
                btnText.textContent = originalBtnText;
                alert("没有可下载的切片");
                return;
            }

            btnText.textContent = "正在压缩...";

            zip.generateAsync({type:"blob"}).then(function(content) {
                const link = document.createElement("a");
                link.href = URL.createObjectURL(content);
                link.download = `${folderName}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Reset UI
                processBtn.disabled = false;
                btnText.textContent = originalBtnText;
                
                // Show Success
                successText.textContent = `已成功打包 ${processedCount} 张表情包 (前缀: ${prefix})`;
                successMsg.classList.remove('hidden');
            });
        }
        
        // 初始化
        updateButtonState();
    </script>
</body>
</html>
